<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>References - Gradient Analyser</title>
	<style>
		.row {display: table-row;}
		.cell {display: table-cell; vertical-align: top;}
		#switcher {list-style: none; margin: 0;}
	</style>
</head>
<body>
	<div class="row">
		<div class="cell">
			<canvas id="orig"></canvas>
		</div>
		<div class="cell">
			<ul id="switcher">
				<li><label><input type="radio" name="imgType" value="visualArrows"> Visual: Arrows for magnitude/orientation</label></li>
				<li><label><input type="radio" name="imgType" value="visualBackground"> Visual: Arrows for orientation, bg for magnitude</label></li>
				<li><label><input type="radio" name="imgType" value="textMagnitude"> Text: Magnitude (percentage)</label></li>
				<li><label><input type="radio" name="imgType" value="textOrient"> Text: Orientation (degrees)</label></li>
				<li><label><input type="checkbox" name="findPoints"> Only show highest magnitude points</label></li>
				<li><label><input type="checkbox" name="wireframes"> Calculate wireframes</label></li>
				<li><input type="range" name="tolMagnitude" value="0" min="0" max="50"> Tolerance: Pixel gradient magnitude % <span id="tolMagnitude-val"></span></li>
				<li><input type="range" name="tolWireframe" value="0" min="0" max="50"> Tolerance: Wireframe neighbour-match magnitude % <span id="tolWireframe-val"></span></li>
			</ul>
		</div>
	</div>
	<canvas id="mag"></canvas>
	<div id="output"></div>
	<script src="../webcam/hog-processing.js"></script>
	<script>
		/* Config */
		var width = 128;
		var height = 96;
		var imgSrc = '../tiles/img/catimov.jpg';
		// var imgSrc = '../common/handy.jpg';
		var magPower = 4; // Power, not multiplier (e.g. 4 => pow(2, 4) => 16)
		var fontSizePx = 8;
		/* End Config */

		var timings = [];
		var orig = document.getElementById('orig');
		var mag = document.getElementById('mag');
		var origCtx = orig.getContext('2d');
		var magCtx = mag.getContext('2d');
		magCtx.mozImageSmoothingEnabled = false;
		magCtx.webkitImageSmoothingEnabled = false;

		var pow = Math.pow(2, magPower);
		var options = {
			findPoints: false,
			wireframes: false,
			tolerance: {
				tolMagnitude: 0,
				tolWireframe: 0
			}
		};
		var currentMethod = '';
		var origData, intensities, vectors, wfCache;

		function setup() {
			orig.width  = width;
			orig.height = height;
			mag.width  = width  * pow;
			mag.height = height * pow;
			magCtx.font = fontSizePx + 'px sans-serif';
			magCtx.textAlign = 'center';
			var switcher = document.getElementById('switcher');
			switcher.addEventListener('click', inputClick, false);
			switcher.addEventListener('change', toleranceChange, false);
			loadSrc();
		}

		function inputClick(e) {
			var input = e.target;
			if (input.nodeName == 'INPUT') {
				var name = input.name;
				if (name == 'imgType') {
					var method = input.value;
					setTimeout(function () {
						currentMethod = method;
						drawGradients(method);
					});
				} else if (input.type == 'checkbox') {
					options[name] = input.checked;
					setTimeout(function () {
						drawPixelOptions[name](input.checked);
						drawGradients(currentMethod);
					});
				}
			}
		}

		function checkboxClick(e) {
			var name = e.target.name;
		}

		var tolTimer;
		function toleranceChange(e) {
			var input = e.target;
			if (input.type !== 'range') {
				return;
			}
			var name = input.name;
			options.tolerance[name] = input.value / 100;
			var output = document.getElementById(name + '-val');
			if (output) {
				output.innerText = '(' + input.value + ')';
			}
			if (tolTimer) {
				clearTimeout(tolTimer);
			}
			tolTimer = setTimeout(function () {
				getVectors();
				drawGradients(currentMethod);
			}, 500);
		}

		function loadSrc() {
			var img = new Image();
			img.onload = function () {
				origCtx.drawImage(img, 0, 0, width, height);
				drawOrig();
			}
			img.src = imgSrc;
		}

		function drawOrig() {
			origData = origCtx.getImageData(0, 0, width, height);
			origData = convertToGreyscale(origData);
			origCtx.putImageData(origData, 0, 0);
			getVectors();
			drawGradients();
		}

		function convertToGreyscale(origData, tolerance) {
			var pixels = origData.data;
			var i = pixels.length;
			var luma;
			while (i) {
				i -= 4;
				luma = pixels[i] * 299/1000 + pixels[i + 1] * 587/1000 + pixels[i + 2] * 114/1000;
				if (tolerance && luma < tolerance) {
					luma = 0;
				}
				pixels[i] = pixels[i + 1] = pixels[i + 2] = luma;
			}
			return origData;
		}

		function getVectors() {
			if (!intensities) {
				intensities = processing.intensities(origData);
			}
			// Inline replacement of processing.gradientVectors()
			var x, y;
			y = height;
			vectors = new Array(height);
			while (y--) {
				vectors[y] = new Array(width);
				x = width;
				while (x--) {
					var prevX = x == 0 ? 0 : intensities[y][x - 1];
					var nextX = x == width - 1 ? 0 : intensities[y][x + 1];
					var prevY = y == 0 ? 0 : intensities[y - 1][x];
					var nextY = y == height - 1 ? 0 : intensities[y + 1][x];

					// kernel [-1, 0, 1]
					var gradX = -prevX + nextX;
					var gradY = -prevY + nextY;

					var mag = Math.sqrt(gradX * gradX + gradY * gradY);
					if (mag < options.tolerance.tolMagnitude) {
						mag = 0;
					}
					vectors[y][x] = {
						mag: mag,
						orient: Math.atan2(gradY, gradX)
					}
				}
			}

			// Find only relatively strongest pixels
			if (options.findPoints) {
				var newVec = new Array(height);
				y = height;
				var x1, x2, y1, y2, vec;
				while (y--) {
					newVec[y] = new Array(width);
					x = width;
					y1 = y && y - 1;
					y2 = y < (height - 1) ? y + 1 : y;
					while (x--) {
						x1 = x && x - 1;
						x2 = x < (width - 1) ? x + 1 : x;
						var maxSurround = Math.max(
							vectors[y1][x1].mag,
							vectors[y1][x].mag,
							vectors[y1][x2].mag,
							vectors[y][x1].mag,
							vectors[y][x2].mag,
							vectors[y2][x1].mag,
							vectors[y2][x].mag,
							vectors[y2][x2].mag
						);
						vec = vectors[y][x];
						newVec[y][x] = {
							orient: vec.orient,
							mag: vec.mag >= maxSurround ? vec.mag : 0
						};
					}
				}
				vectors = newVec;
			}
			vectors[-1] = new Array(width);
			y = height;
			while (y >= 0) {
				vectors[--y][-1] = {mag: 0, orient: 0};
			}
			x = width;
			while (x--) {
				vectors[-1][x] = {mag: 0, orient: 0};
			}
		}

		function drawArrow(ctx, pixel) {
			var p2 = pow / 2;
			var p3 = pow / 3;
			ctx.translate(p2, p2);
			ctx.rotate(pixel.orient);
			ctx.translate(-p2, -p2);
			ctx.beginPath();
			ctx.moveTo(0, p3);
			ctx.lineTo(pow - p2, p3);
			ctx.lineTo(pow - p2, 0);
			ctx.lineTo(pow, p2);
			ctx.lineTo(pow - p2, pow);
			ctx.lineTo(pow - p2, pow - p3);
			ctx.lineTo(0, pow - p3);
			ctx.closePath();
			ctx.fill();
		}

		function drawWireframeArrow(ctx, x1, y1, x2, y2) {
			var p2 = pow / 2;
			var p4 = pow / 3;
			var p6 = pow / 6;
			var angle = Math.atan2(y2 - y1, x2 - x1);
			var tx = x1 * pow + p2;
			var ty = y1 * pow + p2;
			ctx.translate(tx, ty);
			ctx.rotate(angle);
			ctx.beginPath();
			ctx.moveTo(0, 0);
			ctx.lineTo(pow, 0);
			ctx.lineTo(pow - p4, -p6);
			ctx.lineTo(pow, 0);
			ctx.lineTo(pow - p4, p6);
			ctx.stroke();
		}

		function drawWireframes() {
			if (!options.wireframes) {
				return;
			}
			wfCache = new Array(height);
			var x, y, x1, x2, y1, y2, xx, yy, mx, my;
			var cache1, cache2;
			var tolerance = options.tolerance.tolWireframe;
			y = height;
			while (y--) {
				wfCache[y] = new Array(width);
				y1 = y - 1;
				y2 = y < (height - 1) ? y + 1 : -1;
				x = width;
				while (x--) {
					if (vectors[y][x].mag === 0) {
						continue;
					}
					x1 = x - 1;
					x2 = x < (width - 1) ? x + 1 : -1;
					var maxSurround = Math.max(
						vectors[y1][x1].mag,
						vectors[y1][x].mag,
						vectors[y1][x2].mag,
						vectors[y][x1].mag,
						vectors[y][x2].mag,
						vectors[y2][x1].mag,
						vectors[y2][x].mag,
						vectors[y2][x2].mag
					);
					wfCache[y][x] = {length: 0};
					if (maxSurround > 0) {
						mx = x2 > -1 ? x2 : x;
						my = y2 > -1 ? y2 : y;
						for (xx = x1; xx <= mx; xx++) {
							for (yy = y1; yy <= my; yy++) {
								if (
									(xx != x || yy != y) &&
									vectors[yy][xx].mag > 0 &&
									vectors[yy][xx].mag >= maxSurround - tolerance
								) {
									cache1 = [y, x].join('/');
									cache2 = [yy, xx].join('/');
									wfCache[y][x][cache2] = true;
									wfCache[y][x].length++;
									magCtx.save();
									magCtx.strokeStyle = 'rgba(0,200,0,0.7)';
									magCtx.lineWidth = 2;
									if (wfCache[yy] && wfCache[yy][xx] && (cache1 in wfCache[yy][xx])) {
										magCtx.strokeStyle = 'rgba(0,200,200,0.9)';
										magCtx.lineWidth = 4;
									}
									drawWireframeArrow(magCtx, x, y, xx, yy);
									magCtx.restore();
								}
							}
						}
					}
				}
			}
		}

		var drawPixelOptions = {
			findPoints: function () {
				getVectors();
			},
			wireframes: function (enable) {
				if (enable) {
					drawWireframes();
				}
			}
		};

		var drawPixelMethods = {
			enlarge: function (ctx, x, y) {
				ctx.fillStyle = getOrigRGB(x, y);
				ctx.fillRect(x * pow, y * pow, pow, pow);
			},
			visualArrows: function (ctx, x, y) {
				var pixel = vectors[y][x];
				ctx.fillStyle = getMagRGB(pixel.mag);
				ctx.save();
				ctx.translate(x * pow, y * pow);
				drawArrow(ctx, pixel);
				ctx.restore();
			},
			visualBackground: function (ctx, x, y) {
				var pixel = vectors[y][x];
				ctx.fillStyle = getMagRGB(pixel.mag);
				ctx.fillRect(x * pow, y * pow, pow, pow);
				ctx.fillStyle = 'rgba(255,0,0,0.5)';
				ctx.save();
				ctx.translate(x * pow, y * pow);
				drawArrow(ctx, pixel);
				ctx.restore();
			},
			textMagnitude: function (ctx, x, y) {
				var pixel = vectors[y][x];
				ctx.fillStyle = getOrigRGB(x, y);
				ctx.fillRect(x * pow, y * pow, pow, pow);
				ctx.strokeStyle = 'rgba(255,0,0,0.8)';
				ctx.strokeText(getPercentage(pixel.mag), (x + 0.5) * pow, (y + 0.75) * pow);
			},
			textOrient: function (ctx, x, y) {
				var pixel = vectors[y][x];
				ctx.fillStyle = getOrigRGB(x, y);
				ctx.fillRect(x * pow, y * pow, pow, pow);
				ctx.strokeStyle = 'rgba(255,0,0,0.8)';
				ctx.strokeText(getDegrees(pixel.orient), (x + 0.5) * pow, (y + 0.5) * pow);
			}
		};

		/**
		 * Valid methods:
		 *  'enlarge'          => Direct image copy
		 *  'visualArrows'     => Plain background, arrows showing orientation/magnitude
		 *  'visualBackground' => Background showing magnitude, arrows showing orientation
		 *  'textMagnitude'    => Background showing greyscale, text for magnitude (percentage)
		 *  'textOrient'       => Background showing greyscale, text for orientation (degrees)
		 *
		 * Tolerance is 0 to 1, any pixel less than tolerance magnitude has no display
		 */
		function drawGradients(method, tolerance) {
			method || (method = 'enlarge');
			tolerance = +tolerance || 0;

			magCtx.clearRect(0, 0, width * pow, height * pow);
			var y = height;
			var x;
			while (y--) {
				x = width;
				while (x--) {
					drawPixelMethods[method](magCtx, x, y);
				}
			}

			drawWireframes();
		}

		function getMagRGB(magnitude) {
			magnitude = 1 - magnitude; // Invert
			var rgbMag = (256 + Math.round(magnitude * 255)).toString(16).substr(1);
			return '#' + rgbMag + rgbMag + rgbMag;
		}

		function getOrigRGB(x, y) {
			// var rgb = (256 + origData.data[(y * width + x) * 4]).toString(16).substr(1);
			// return '#' + rgb + rgb + rgb;
			var rgb = origData.data[(y * width + x) * 4];
			return 'rgba(' + [rgb, rgb, rgb].join(',') + ', 1)';
		}

		function getPercentage(num) {
			return Math.round(num * 100)// + '%';
		}

		function getDegrees(rad) {
			var deg = Math.round(rad * 180 / Math.PI % 360);
			return deg// + '°';
		}

		setup();
	</script>
</body>
</html>