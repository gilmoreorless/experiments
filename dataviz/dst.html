<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Daylight saving time around the world</title>
    <link rel="stylesheet" href="../main.css">

    <style>
        body {
            margin-top: 0;
        }
        .controls {
            background: #fff;
            border-radius: 0 5px 5px 0;
            left: 0;
            position: fixed;
            text-align: left;
            top: 70px;
        }
        .controls h3 {
            font-size: inherit;
            margin: 0.25em 0;
        }
        .controls label {
            display: block;
        }
        .legend {
            margin-top: 1em;
        }
        .legend text {
            text-anchor: middle;
            pointer-events: none;
        }
        svg {
            display: block;
            margin: 0 auto;
        }
        text {
            font-size: 14px;
        }
        .desc, #titles-container {
            background: #D4E9F2;
            position: fixed;
            width: 960px;
        }
        .desc {
            margin: 0;
            padding: 10px 0;
        }
        #titles-container {
            background: linear-gradient(to bottom, #D4E9F2 0, #D4E9F2 19px, rgba(0, 0, 0, 0) 100%);
            height: 30px;
            top: 45px;
        }
        .month-name text {
            text-anchor: middle;
        }
        #zones-container {
            padding-top: 70px;
        }
        .changes rect {
            fill: hsl(20, 60%, 70%);
            stroke: none;
        }
        .changes .dst {
            fill: hsl(35, 100%, 70%);
            stroke: hsl(35, 50%, 20%);
            stroke-width: 1;
        }
        .changes .dst:hover {
            fill: hsl(35, 100%, 80%);
        }
        .gmt-offset text {
            font-size: 12px;
            font-family: monospace;
        }
        .month-line {
            stroke: rgba(0, 0, 0, 0.2);
            stroke-width: 1;
            stroke-dasharray: 5, 5;
        }
    </style>
</head>

<body class="centre">
<div id="controls" class="controls">
    <h3>Sort By</h3>
    <label><input type="radio" name="sort" value="dstStart" checked> DST start date</label>
    <label><input type="radio" name="sort" value="offset"> GMT offset</label>
    <hr>
    <label><input type="checkbox" name="groupSame"> Group identical zones</label>
    <div class="legend">
        <h3>Legend</h3>
    </div>
</div>
<p class="desc">
    Daylight saving rules around the world <small>(probably already out of date)</small>
</p>
<div id="titles-container">
</div>
<div id="zones-container"></div>

<script src="../common/js/d3.js"></script>
<script src="../common/js/underscore.js"></script>
<script src="../common/js/moment.js"></script>
<script src="../common/js/shimShiminy.js"></script>
<script>
function offsetNum(str) {
    var parts = str.split(':');
    var num = +parts[0];
    if (parts[1]) {
        var extra = +parts[1] / 60;
        num = num > 0 ? num + extra : num - extra;
    }
    return num;
}

function offsetStr(num) {
    var hours = num | 0;
    var mins = (num % 1) * 60;
    var str = hours < 0 ? '-' : '+';
    hours = Math.abs(hours);
    str += ('0' + hours).slice(-2);
    str += ':' + ('0' + mins).slice(-2);
    return str;
}

// Copied from moment-timezone/zones.js
function getFirstDayOfWeek(year, month, dayOfWeek, minDay) {
    var firstDayOfWeek = moment([year, month, 1]).day(),
        output = dayOfWeek + 1 - firstDayOfWeek;

    while (output < minDay) {
        output += 7;
    }

    return output;
}

// Copied from moment-timezone/zones.js
function getLastDayOfWeek(year, month, dayOfWeek) {
    var dow = dayOfWeek % 7,
        lastDowOfMonth = moment([year, month + 1, 1]).day(),
        daysInMonth = moment([year, month, 1]).daysInMonth(),
        output = daysInMonth + (dow - (lastDowOfMonth - 1)) - (~~(dayOfWeek / 7) * 7);

    if (dow >= lastDowOfMonth) {
        output -= 7;
    }

    return output;
}

d3.json('moment-timezone.json', function (tzdata) {

    /*** Config ***/

    var labelPadding = 3;
    var labelHeight = 20;
    var labelWidth = 270;
    var yearWidth = 365;
    var gmtOffsetWidth = 80;
    var transitionSpeed = 500;

    /*** Data preparation ***/

    var zones = [];
    var rules = {};
    var year = new Date().getFullYear();
    var groupedZones;

    _.each(tzdata.zones, function (data, id) {
        var zone = _.last(data);
        var info = zone.split(' ');
        var rule = info[1];
        var offset = offsetNum(info[0]);
        zones.push({
            id: id,
            offset: offset,
            offsetStr: offsetStr(offset),
            rule: rule
        });
        if (rule != '-') {
            rules[rule] = {
                name: rule,
                change: []
            };
        }
    });
    _.each(rules, function (data, name) {
        var rule = tzdata.rules[name];
        if (!rule) {
            console.error('NO RULE FOR ' + name);
        }
        // Special hard-coded 2013 case for crazy rules of Morocco
        if (name == 'Morocco') {
            rule = [
                "2013 2013 7 8 7 2 0 1 S",
                "2013 9999 9 0 8 3 0 0",
                "2012 2019 2 0 8 2 0 1 S",
                "2013 2013 6 9 7 3 0 0",
            ];
        }
        var i = rule.length;
        var info;
        while (i--) {
            info = rule[i].split(' ');
            if (info[1] == '9999' || name == 'Morocco') {
                data.change.push(_.rest(info, 2));
            }
        }
    });

    _.each(zones, function (zone) {
        var rule = rules[zone.rule];
        if (rule) {
            _.each(rule.change, function (change) {
                // console.log(change)
                var month = +change[0];
                var day = +change[1];
                var dayRule = +change[2];
                var saveParts = change[5].split(':');
                var save = +saveParts[0];
                if (saveParts.length > 1) {
                    save += (+saveParts[1] || 0) / 60;
                }
                var isDST = save > 0;
                var prop = isDST ? 'dstStart' : 'dstEnd';
                // Special case for Morocco again
                if (zone[prop]) {
                    prop += '2';
                }

                if (dayRule === 8) { // "last <day> of month"
                    day = getLastDayOfWeek(year, month, day);
                } else if (dayRule < 7) { // "first <dayRule> >= <day>"
                    day = getFirstDayOfWeek(year, month, dayRule, day)
                }
                var date = moment([year, month, day || 1]);
                zone[prop] = date;
                zone[prop + 'Value'] = [month, date.date(), save];
            });
        }

        var sortValue = 1300100; // mmdd1oo
        if (zone.dstStartValue) {
            sortValue = zone.dstStartValue[0] * 100000 +
                zone.dstStartValue[1] * 1000 + 100;
        }
        sortValue += zone.offset;
        zone.sortValue = sortValue;
    });
    zones = _.sortBy(zones, 'sortValue');
    groupedZones = _.chain(zones)
        .groupBy(function (zone) {
            var key = zone.id.split('/').slice(0, 1);
            key.push(
                zone.offset,
                zone.dstStartValue || '-',
                zone.dstEndValue || '-',
                zone.dstStart2Value ? '1' : '0'
            );
            return key.join('/');
        }).map(function (zoneList, key) {
            var zone = _.clone(zoneList[0]);
            if (zoneList.length === 1) {
                return zone;
            }
            key = key.split('/');
            zone.id = key[0] + '/(' + zone.offsetStr + ', ' + zoneList.length + ' zones)';
            zone.zoneIds = _.pluck(zoneList, 'id');
            return zone;
        })
        .sortBy('sortValue')
        .value();


    /*** Display ***/

    var sortMode = 'dstStart';
    var isGrouped = false;

    var dateX = window.dateX = d3.scale.linear()
        .domain([1, 365])
        .range([1, yearWidth])

    function zoneY(x) {
        x = +x || 0;
        var transform = d3.transform();
        transform.translate[0] = x;

        var fn = function (d, i) {
            transform.translate[1] = i * (labelHeight + labelPadding) + labelPadding;
            return transform;
        };
        fn.scale = function (sx, sy) {
            sx = arguments.length < 1 ? 1 : +sx || 0;
            sy = arguments.length < 2 ? 1 : +sy || 0;
            transform.translate[0] += (labelWidth + yearWidth + gmtOffsetWidth) / 2 * (1 - sx);
            transform.scale = [sx, sy];
            return fn;
        };
        return fn;
    }

    function dstPathBlock(x1, x2) {
        x1 = dateX(x1);
        x2 = dateX(x2);
        var path = [
            'M', x1, 0,
            'L', x2, 0,
                 x2, labelHeight,
                 x1, labelHeight,
            'z'
        ];
        return path;
    }

    function dstPath(suffix) {
        suffix || (suffix = '');
        var startProp = 'dstStart' + suffix;
        var endProp = 'dstEnd' + suffix;
        return function (d) {
            var startDay = d[startProp].dayOfYear();
            var endDay = d[endProp].dayOfYear();
            var path = [];

            if (endDay > startDay) {
                path = dstPathBlock(startDay, endDay);
            } else {
                path = dstPathBlock(startDay, 365).concat(dstPathBlock(0, endDay));
            }

            return path.join(' ');
        }
    }


    // Legend

    var legend = d3.select('.legend').append('svg')
        .attr('height', (labelHeight + labelPadding) * 2 + labelPadding)
        .append('g')
            .classed('changes', true)

    legend.append('rect')
        .attr('width', '98%')
        .attr('height', labelHeight)
        .attr('transform', 'translate(2,0)')
    legend.append('text')
        .text('Normal GMT offset')
        .attr('y', labelHeight)

    legend.append('rect')
        .classed('dst', true)
        .attr('width', '98%')
        .attr('height', labelHeight)
        .attr('transform', 'translate(2,' + (labelHeight + labelPadding * 2) + ')')
    legend.append('text')
        .text('Daylight saving')
        .attr('y', (labelHeight + labelPadding) * 2)

    legend.selectAll('text')
        .attr('x', '50%')
        .attr('dy', -5)

    // Titles

    var titles = d3.select('#titles-container').append('svg')
        .attr('width', labelWidth + yearWidth + gmtOffsetWidth)
        .attr('height', labelHeight + labelPadding)

    titles.append('text')
        .attr('y', labelHeight * .8)
        .text('Zone ID')
        .style('font-style', 'italic')

    var months = [];
    for (var m = 0; m < 12; m++) {
        months.push(moment([year, m, 1]));
    }

    titles.append('g')
        .attr('transform', 'translate(' + labelWidth + ',0)')
    .selectAll('.month-name')
        .data(months)
        .enter().append('g')
            .classed('month-name', true)
            .attr('transform', function (d) { return 'translate(' + dateX(d.dayOfYear()) + ',0)' })
            .append('text')
                .attr('y', labelHeight * .8)
                .text(function (d) { return d.format('MMM').substr(0, 1) })


    // Data display

    var svg = d3.select('#zones-container').append('svg')
        .attr('width', labelWidth + yearWidth + gmtOffsetWidth)
        .attr('height', (labelHeight + labelPadding) * zones.length + labelPadding)

    var listGroup = svg.append('g').classed('list-group', true);

    var list;

    function display() {
        var data = isGrouped ? groupedZones : zones;
        list = listGroup.selectAll('.zone-data')
            .data(data, function (d) { return d.id + (d.dstStartValue || '') })

        list.exit()
            .transition()
            .duration(transitionSpeed)
            .attr('transform', zoneY().scale(0))
            .remove();


        var newZones = list.enter().append('g')
            .classed('zone-data', true)
            .attr('transform', zoneY().scale(0))

        list.transition()
            .duration(transitionSpeed)
            .attr('transform', zoneY().scale(1))

        newZones.append('g').classed('zone-id', true)
            .append('text')
                .attr('y', labelHeight * .8)
                .text(function (d) { return d.id });

        var changes = newZones.append('g')
            .classed('changes', true)
            .attr('transform', 'translate(' + labelWidth + ',0)')
        changes.append('rect')
            .attr('width', yearWidth)
            .attr('height', labelHeight)

        newZones.append('g')
            .classed('gmt-offset', true)
            .attr('transform', 'translate(' + (labelWidth + yearWidth + 10) + ',0)')
            .append('text')
                .attr('y', labelHeight * .8)
                .text(function (d) { return d.offsetStr })

        var dst = changes.filter(function (d) { return !!d.dstStart })

        dst.append('path')
            .classed('dst', true)
            .attr('d', dstPath())
            .attr('translate', 'transform(' + labelWidth + ',0)')
            // .text(function (d) {
            //     return ~~(d.sortValue / 1000)
            // })

        // YET MORE MOROCCO SPECIAL CODE
        dst.filter(function (d) { return d.id == 'Africa/Casablanca' }).append('path')
            .classed('dst', true)
            .attr('d', dstPath('2'))
            // .text(function (d) {
            //     var sortValue = d.dstStart2Value[0] * 100000 + d.dstStart2Value[1] * 1000 + 100;
            //     return ~~(sortValue / 1000);
            // })

        // Make sure the DOM nodes are in the right order, as it affects animation positions
        list.sort(sortData);
    }
    display();

    svg.append('g')
        .classed('month-line-group', true)
        .selectAll('.month-line')
            .data(months)
            .enter().append('line')
                .classed('month-line', true)
                .attr('x1', 0).attr('x2', 0)
                .attr('y1', labelPadding).attr('y2', svg.attr('height') - labelPadding)
                .attr('transform', function (d) { return 'translate(' + (labelWidth + dateX(d.dayOfYear())) + ',0)' })


    // Data manipulation

    function sortData(a, b) {
        var prop = 'sortValue';
        if (sortMode === 'offset' && a.offset != b.offset) {
            prop = 'offset';
        }
        var diff = a[prop] - b[prop];
        if (diff !== 0) {
            return diff;
        }
        return a.id < b.id ? -1 : 1;
    }

    function setSortMode(mode) {
        sortMode = mode;
        zones.sort(sortData);
        groupedZones.sort(sortData);
        display();
    }

    function setGrouping(shouldGroup) {
        isGrouped = !!shouldGroup;
        display();
    }


    /*** Interactive controls ***/

    document.getElementById('controls').addEventListener('change', function (e) {
        var elem = e.target;
        if (elem.nodeName == 'INPUT') {
            if (elem.name == 'sort') {
                setSortMode(elem.value);
            } else if (elem.name == 'groupSame') {
                setGrouping(elem.checked);
            }
        }
    }, false)
});
</script>
</body>
</html>