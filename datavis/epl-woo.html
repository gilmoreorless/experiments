<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>English Premier League “Window of Opportunity”</title>
    <link rel="stylesheet" href="../main.css">

    <style>
        :root {
            --colour: #333;
        }
        .controls {
            background: #fff;
            border-radius: 5px;
            text-align: left;
        }
        .slider {
            display: flex;
        }
        .slider label {
            width: 7rem;
        }
        .slider input[type="range"] {
            width: 20rem;
        }
        .slider output {
            margin-left: 0.5rem;
        }

        .team-line,
        .team-prediction {
            fill: none;
            stroke: var(--colour);
            stroke-width: 1;
        }
        .team-prediction {
            stroke-dasharray: 1 1;
        }
        .team-opportunity,
        .team-opportunity-clone {
            fill: var(--colour);
            stroke: var(--colour);
            stroke-width: 1;
        }
    </style>
</head>

<body class="centre">
<div class="controls">
    <div class="slider">
        <label for="start-round">Start round:</label>
        <input id="start-round" type="range" min="0">
        <output for="start-round"></output>
    </div>
    <div class="slider">
        <label for="end-round">End round:</label>
        <input id="end-round" type="range" min="0">
        <output for="end-round"></output>
    </div>
    <div class="animations">
        <button id="anim-play-pause" type="button">Play animation</button>
    </div>
</div>
<div id="graph-container"></div>

<script src="../common/js/d3.v5.js"></script>
<script src="../common/js/shimShiminy.js"></script>
<script>
/**
 * TODO:
 *
 * - Restrict start/end sliders to appropriate range based on the other slider.
 * - Find a better colour scheme.
 * - Switch X scale to date-based.
 * - Add X/Y axis ticks.
 */

/*** Config ***/

let teamCount = 20;
let rounds = 38;
let startAtRound = 0;
let stopAtRound = 36;
let pointsPerWin = 3;
let pointsPerDraw = 1;

let width = 940;
let height = 600;
let margin = 10;


/*** Derived values ***/

let opacityPerRound = d3.scaleLinear([0, rounds * 3], [0, 1]);
let xScale = d3.scaleLinear([startAtRound, rounds], [margin, width - margin * 2]);
let yScale = d3.scaleLinear([0, 1], [height - margin * 2, margin]);
let colours = d3.interpolateRainbow;


/*** Controls ***/

function getSlider(id) {
    let input = document.getElementById(id); // Just assume this exists
    let output = document.querySelector(`output[for="${id}"]`);

    function updateOutput() {
        output.textContent = input.value;
    }

    function valueChanged() {
        updateOutput();
        if (id === 'start-round') {
            startAtRound = parseFloat(input.value) || 0;
        }
        if (id === 'end-round') {
            stopAtRound = parseFloat(input.value) || 1;
        }
        render();
    }

    input.addEventListener('input', valueChanged);

    return {
        input,
        output,
        setValue: (value) => {
            input.value = value;
            updateOutput();
        },
        setMin: (value) => { input.min = value; },
        setMax: (value) => { input.max = value; },
    }
}

let sliders = {
    startRound: getSlider('start-round'),
    endRound: getSlider('end-round'),
};


/*** Animation ***/

let anim = {
    isPlaying: false,
    stepDelay: 200,
    timer: null,
    button: document.getElementById('anim-play-pause'),
};

function startAnimation() {
    anim.isPlaying = true;
    startAtRound = 0;
    stopAtRound = 0;
    sliders.startRound.setValue(startAtRound);
    sliders.endRound.setValue(stopAtRound);
    anim.timer = d3.interval(animationTick, anim.stepDelay);
    anim.button.textContent = 'Stop animation';
    render();
}

function stopAnimation() {
    anim.isPlaying = false;
    anim.timer.stop();
    anim.button.textContent = 'Play animation';
}

function animationTick(elapsed) {
    if (stopAtRound >= rounds) {
        stopAnimation();
        return;
    }
    stopAtRound++;
    sliders.endRound.setValue(stopAtRound);
    render({ useTransition: true });
}

anim.button.addEventListener('click', function () {
    if (anim.isPlaying) {
        stopAnimation();
    } else {
        startAnimation();
    }
}, false);


/*** Chart setup ***/

let svg = d3.select('#graph-container').append('svg')
    .attr('width', width)
    .attr('height', height)
let root = svg.append('g')
    .attr('class', 'root')
    .attr('transform', `translate(${margin}, ${margin})`)


/*** Load data ***/

let teamsMap, teamsArr;

function first(array) {
    return array[0];
}

function last(array, defaultValue) {
    return array.length ? array[array.length - 1] : defaultValue;
}

function rowParser(row) {
    let parts = row.Date.split('/');
    return {
        // Convert dd/mm/yy to yyyy-mm-dd
        date: `20${parts[2]}-${parts[1]}-${parts[0]}`,
        home: row.HomeTeam,
        away: row.AwayTeam,
        result: row.FTR,
    };
}

function addResult(map, team, points) {
    let results = map.get(team) || [0];
    let prev = last(results);
    results.push(prev + points);
    map.set(team, results);
}

function update() {
    sliders.startRound.setMax(rounds - 1);
    sliders.startRound.setValue(startAtRound);
    sliders.endRound.setMax(rounds);
    sliders.endRound.setValue(stopAtRound);
    render();
}

function render({ useTransition } = {}) {
    let transition = d3.transition();
    if (useTransition) {
        transition
            .duration(anim.stepDelay)
            .ease(d3.easeLinear)
    }

    let teams = teamsArr.map(teamPoints => teamPoints.slice(startAtRound, stopAtRound + 1));
    xScale.domain([startAtRound, rounds]);

    // Work out available points range
    let minPoints = d3.min(teams, first);
    // let maxPoints = d3.max(teams, last);
    let roundsRemaining = rounds - stopAtRound;
//     let maxAvailablePoints = maxPoints + pointsPerWin * roundsRemaining;
    let maxAvailablePoints = pointsPerWin * rounds;
    yScale.domain([minPoints, maxAvailablePoints]);

    /*** Render data ***/

    let lineGenerator = d3.line()
        .x((_, i) => xScale(i + startAtRound))
        .y(yScale)

    // TODO: Remove the need for this by altering lineGenerator to not
    //       rely on array index, but instead have extra data in the array
    let tempPredictionGenerator = d3.line()
        .x((_, i) => xScale(i === 0 ? stopAtRound : rounds))
        .y(yScale)

    let triangleGenerator = d3.line()
        .x(d => xScale(d[0]) - 1)
        .y(d => yScale(d[1]))

    let teamNodes = root.selectAll('.team')
        .data(teams)
        .join(
            enter => enter.append('g')
                .attr('class', 'team')
                .style('--colour', (_, i) => colours(i / teamCount))
        )

    let teamLines = teamNodes.selectAll('.team-line')
        .data(d => [d])
        .join(
            enter => enter.append('path')
                .attr('class', 'team-line')
        )

    if (useTransition) {
        teamLines
            .transition(transition)
            .attrTween('d', function(d, i) {
                let finalPath = lineGenerator(d);
                let pathBits = finalPath.split('L');
                pathBits[pathBits.length - 1] = pathBits[pathBits.length - 2];
                let initialPath = pathBits.join('L');
                return d3.interpolateString(initialPath, finalPath);
            })
    } else {
        teamLines.attr('d', lineGenerator)
    }

    let teamOpps = teamNodes.selectAll('.team-opportunity')
        .data(d => [d])
        .join(
            enter => enter.append('path')
                .attr('class', 'team-opportunity')
        )

    if (useTransition) {
        teamOpps = teamOpps.transition(transition)
    }
    teamOpps
        .attr('d', d => triangleGenerator([
            [stopAtRound, last(d)],
            [rounds, last(d)],
            [rounds, last(d) + pointsPerWin * roundsRemaining],
        ]) + 'Z')
        .style('opacity', opacityPerRound(stopAtRound))

    let teamPredictions = teamNodes.selectAll('.team-prediction')
        .data(totals => {
            // TODO: Include points-per-match data in each item, to avoid calculating this
            let prevTotal = 0;
            let pointsPerMatch = totals.map(total => {
                let thisMatch = total - prevTotal;
                prevTotal = total;
                return thisMatch;
            });
            let avg = d3.mean(pointsPerMatch);
            let latestTotal = last(totals);
            return [[latestTotal, latestTotal + avg * roundsRemaining]];
        })
        .join(
            enter => enter.append('path')
                .attr('class', 'team-prediction')
        )

    if (useTransition) {
        teamPredictions = teamPredictions.transition(transition)
    }
    teamPredictions.attr('d', tempPredictionGenerator)
}

// CSV from football-data.org.uk
d3.csv('epl-1718.csv', rowParser).then(rows => {
    teamsMap = new Map();

    /*** Process data ***/

    rows.forEach(row => {
        let homePts = 0;
        let awayPts = 0;
        switch (row.result) {
            case 'H': homePts = pointsPerWin; break;
            case 'A': awayPts = pointsPerWin; break;
            case 'D': homePts = pointsPerDraw; awayPts = pointsPerDraw; break;
        }

        addResult(teamsMap, row.home, homePts);
        addResult(teamsMap, row.away, awayPts);
    });

    // Reduce team points to array of arrays
    teamsArr = [...teamsMap.values()] //.slice(0, 1);
    teamsArr.sort((a, b) => d3.descending(last(a), last(b)));

    update();
});

</script>
</body>
</html>
